/*
 * Safe Transaction Service API
 *
 * API to keep track of transactions sent via Gnosis Safe smart contracts
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`v1_contracts_list`]
#[derive(Clone, Debug, Default)]
pub struct V1ContractsListParams {
    /// Which field to use when ordering the results.
    pub ordering: Option<String>,
    /// Number of results to return per page.
    pub limit: Option<i32>,
    /// The initial index from which to return the results.
    pub offset: Option<i32>
}

/// struct for passing parameters to the method [`v1_contracts_read`]
#[derive(Clone, Debug, Default)]
pub struct V1ContractsReadParams {
    /// A unique value identifying this contract.
    pub address: String
}

/// struct for passing parameters to the method [`v1_data_decoder_create`]
#[derive(Clone, Debug, Default)]
pub struct V1DataDecoderCreateParams {
    pub data: crate::models::DataDecoder
}

/// struct for passing parameters to the method [`v1_delegates_create`]
#[derive(Clone, Debug, Default)]
pub struct V1DelegatesCreateParams {
    pub data: crate::models::Delegate
}

/// struct for passing parameters to the method [`v1_delegates_delete`]
#[derive(Clone, Debug, Default)]
pub struct V1DelegatesDeleteParams {
    pub delegate_address: String,
    pub data: crate::models::DelegateDelete
}

/// struct for passing parameters to the method [`v1_delegates_list`]
#[derive(Clone, Debug, Default)]
pub struct V1DelegatesListParams {
    /// safe
    pub safe: Option<String>,
    /// delegate
    pub delegate: Option<String>,
    /// delegator
    pub delegator: Option<String>,
    /// label
    pub label: Option<String>,
    /// Number of results to return per page.
    pub limit: Option<i32>,
    /// The initial index from which to return the results.
    pub offset: Option<i32>
}

/// struct for passing parameters to the method [`v1_messages_read`]
#[derive(Clone, Debug, Default)]
pub struct V1MessagesReadParams {
    /// A unique value identifying this safe message.
    pub message_hash: std::path::PathBuf
}

/// struct for passing parameters to the method [`v1_messages_signatures_create`]
#[derive(Clone, Debug, Default)]
pub struct V1MessagesSignaturesCreateParams {
    pub message_hash: String,
    pub data: crate::models::SafeMessageSignature
}

/// struct for passing parameters to the method [`v1_module_transaction_read`]
#[derive(Clone, Debug, Default)]
pub struct V1ModuleTransactionReadParams {
    pub module_transaction_id: String
}

/// struct for passing parameters to the method [`v1_modules_safes_list`]
#[derive(Clone, Debug, Default)]
pub struct V1ModulesSafesListParams {
    pub address: String
}

/// struct for passing parameters to the method [`v1_multisig_transactions_confirmations_create`]
#[derive(Clone, Debug, Default)]
pub struct V1MultisigTransactionsConfirmationsCreateParams {
    pub safe_tx_hash: String,
    pub data: crate::models::SafeMultisigConfirmation
}

/// struct for passing parameters to the method [`v1_multisig_transactions_confirmations_list`]
#[derive(Clone, Debug, Default)]
pub struct V1MultisigTransactionsConfirmationsListParams {
    pub safe_tx_hash: String,
    /// Number of results to return per page.
    pub limit: Option<i32>,
    /// The initial index from which to return the results.
    pub offset: Option<i32>
}

/// struct for passing parameters to the method [`v1_multisig_transactions_read`]
#[derive(Clone, Debug, Default)]
pub struct V1MultisigTransactionsReadParams {
    pub safe_tx_hash: String
}

/// struct for passing parameters to the method [`v1_notifications_devices_create`]
#[derive(Clone, Debug, Default)]
pub struct V1NotificationsDevicesCreateParams {
    pub data: crate::models::FirebaseDevice
}

/// struct for passing parameters to the method [`v1_notifications_devices_delete`]
#[derive(Clone, Debug, Default)]
pub struct V1NotificationsDevicesDeleteParams {
    /// A UUID string identifying this Firebase Device.
    pub uuid: String
}

/// struct for passing parameters to the method [`v1_notifications_devices_safes_delete`]
#[derive(Clone, Debug, Default)]
pub struct V1NotificationsDevicesSafesDeleteParams {
    /// A UUID string identifying this Firebase Device.
    pub uuid: String,
    pub address: String
}

/// struct for passing parameters to the method [`v1_owners_safes_list`]
#[derive(Clone, Debug, Default)]
pub struct V1OwnersSafesListParams {
    pub address: String
}

/// struct for passing parameters to the method [`v1_safes_all_transactions_list`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesAllTransactionsListParams {
    pub address: String,
    /// Which field to use when ordering the results.
    pub ordering: Option<String>,
    /// Number of results to return per page.
    pub limit: Option<i32>,
    /// The initial index from which to return the results.
    pub offset: Option<i32>,
    /// If `True` only executed transactions are returned
    pub executed: Option<bool>,
    /// If `True` transactions with `nonce >= Safe current nonce` are also returned
    pub queued: Option<bool>,
    /// If `True` just trusted transactions are shown (indexed, added by a delegate or with at least one confirmation)
    pub trusted: Option<bool>
}

/// struct for passing parameters to the method [`v1_safes_balances_list`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesBalancesListParams {
    pub address: String,
    /// If `True` just trusted tokens will be returned
    pub trusted: Option<bool>,
    /// If `True` spam tokens will not be returned
    pub exclude_spam: Option<bool>
}

/// struct for passing parameters to the method [`v1_safes_balances_usd_list`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesBalancesUsdListParams {
    pub address: String,
    /// If `True` just trusted tokens will be returned
    pub trusted: Option<bool>,
    /// If `True` spam tokens will not be returned
    pub exclude_spam: Option<bool>
}

/// struct for passing parameters to the method [`v1_safes_creation_list`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesCreationListParams {
    pub address: String
}

/// struct for passing parameters to the method [`v1_safes_delegates_delete`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesDelegatesDeleteParams {
    pub address: String,
    pub delegate_address: String,
    pub data: crate::models::SafeDelegateDelete
}

/// struct for passing parameters to the method [`v1_safes_incoming_transfers_list`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesIncomingTransfersListParams {
    pub address: String,
    /// _from
    pub _from: Option<String>,
    /// block_number
    pub block_number: Option<String>,
    /// block_number__gt
    pub block_number__gt: Option<String>,
    /// block_number__lt
    pub block_number__lt: Option<String>,
    /// execution_date__gte
    pub execution_date__gte: Option<String>,
    /// execution_date__lte
    pub execution_date__lte: Option<String>,
    /// execution_date__gt
    pub execution_date__gt: Option<String>,
    /// execution_date__lt
    pub execution_date__lt: Option<String>,
    /// to
    pub to: Option<String>,
    /// token_address
    pub token_address: Option<String>,
    /// transaction_hash
    pub transaction_hash: Option<String>,
    /// value
    pub value: Option<String>,
    /// value__gt
    pub value__gt: Option<String>,
    /// value__lt
    pub value__lt: Option<String>,
    /// erc20
    pub erc20: Option<String>,
    /// erc721
    pub erc721: Option<String>,
    /// ether
    pub ether: Option<String>,
    /// Number of results to return per page.
    pub limit: Option<i32>,
    /// The initial index from which to return the results.
    pub offset: Option<i32>
}

/// struct for passing parameters to the method [`v1_safes_messages_create`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesMessagesCreateParams {
    pub address: String,
    pub data: crate::models::SafeMessage
}

/// struct for passing parameters to the method [`v1_safes_messages_list`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesMessagesListParams {
    pub address: String,
    /// Which field to use when ordering the results.
    pub ordering: Option<String>,
    /// Number of results to return per page.
    pub limit: Option<i32>,
    /// The initial index from which to return the results.
    pub offset: Option<i32>
}

/// struct for passing parameters to the method [`v1_safes_module_transactions_list`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesModuleTransactionsListParams {
    pub address: String,
    /// safe
    pub safe: Option<String>,
    /// module
    pub module: Option<String>,
    /// to
    pub to: Option<String>,
    /// operation
    pub operation: Option<String>,
    /// failed
    pub failed: Option<String>,
    /// block_number
    pub block_number: Option<String>,
    /// block_number__gt
    pub block_number__gt: Option<String>,
    /// block_number__lt
    pub block_number__lt: Option<String>,
    /// transaction_hash
    pub transaction_hash: Option<String>,
    /// Which field to use when ordering the results.
    pub ordering: Option<String>,
    /// Number of results to return per page.
    pub limit: Option<i32>,
    /// The initial index from which to return the results.
    pub offset: Option<i32>
}

/// struct for passing parameters to the method [`v1_safes_multisig_transactions_create`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesMultisigTransactionsCreateParams {
    pub address: String,
    pub data: crate::models::SafeMultisigTransaction
}

/// struct for passing parameters to the method [`v1_safes_multisig_transactions_estimations_create`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesMultisigTransactionsEstimationsCreateParams {
    pub address: String,
    pub data: crate::models::SafeMultisigTransactionEstimate
}

/// struct for passing parameters to the method [`v1_safes_multisig_transactions_list`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesMultisigTransactionsListParams {
    pub address: String,
    /// failed
    pub failed: Option<String>,
    /// modified__lt
    pub modified__lt: Option<String>,
    /// modified__gt
    pub modified__gt: Option<String>,
    /// modified__lte
    pub modified__lte: Option<String>,
    /// modified__gte
    pub modified__gte: Option<String>,
    /// nonce__lt
    pub nonce__lt: Option<String>,
    /// nonce__gt
    pub nonce__gt: Option<String>,
    /// nonce__lte
    pub nonce__lte: Option<String>,
    /// nonce__gte
    pub nonce__gte: Option<String>,
    /// nonce
    pub nonce: Option<String>,
    /// safe_tx_hash
    pub safe_tx_hash: Option<String>,
    /// to
    pub to: Option<String>,
    /// value__lt
    pub value__lt: Option<String>,
    /// value__gt
    pub value__gt: Option<String>,
    /// value
    pub value: Option<String>,
    /// executed
    pub executed: Option<String>,
    /// has_confirmations
    pub has_confirmations: Option<String>,
    /// trusted
    pub trusted: Option<String>,
    /// execution_date__gte
    pub execution_date__gte: Option<String>,
    /// execution_date__lte
    pub execution_date__lte: Option<String>,
    /// submission_date__gte
    pub submission_date__gte: Option<String>,
    /// submission_date__lte
    pub submission_date__lte: Option<String>,
    /// transaction_hash
    pub transaction_hash: Option<String>,
    /// Which field to use when ordering the results.
    pub ordering: Option<String>,
    /// Number of results to return per page.
    pub limit: Option<i32>,
    /// The initial index from which to return the results.
    pub offset: Option<i32>
}

/// struct for passing parameters to the method [`v1_safes_read`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesReadParams {
    pub address: String
}

/// struct for passing parameters to the method [`v1_safes_transactions_create`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesTransactionsCreateParams {
    pub address: String,
    pub data: crate::models::SafeMultisigTransaction
}

/// struct for passing parameters to the method [`v1_safes_transactions_list`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesTransactionsListParams {
    pub address: String,
    /// failed
    pub failed: Option<String>,
    /// modified__lt
    pub modified__lt: Option<String>,
    /// modified__gt
    pub modified__gt: Option<String>,
    /// modified__lte
    pub modified__lte: Option<String>,
    /// modified__gte
    pub modified__gte: Option<String>,
    /// nonce__lt
    pub nonce__lt: Option<String>,
    /// nonce__gt
    pub nonce__gt: Option<String>,
    /// nonce__lte
    pub nonce__lte: Option<String>,
    /// nonce__gte
    pub nonce__gte: Option<String>,
    /// nonce
    pub nonce: Option<String>,
    /// safe_tx_hash
    pub safe_tx_hash: Option<String>,
    /// to
    pub to: Option<String>,
    /// value__lt
    pub value__lt: Option<String>,
    /// value__gt
    pub value__gt: Option<String>,
    /// value
    pub value: Option<String>,
    /// executed
    pub executed: Option<String>,
    /// has_confirmations
    pub has_confirmations: Option<String>,
    /// trusted
    pub trusted: Option<String>,
    /// execution_date__gte
    pub execution_date__gte: Option<String>,
    /// execution_date__lte
    pub execution_date__lte: Option<String>,
    /// submission_date__gte
    pub submission_date__gte: Option<String>,
    /// submission_date__lte
    pub submission_date__lte: Option<String>,
    /// transaction_hash
    pub transaction_hash: Option<String>,
    /// Which field to use when ordering the results.
    pub ordering: Option<String>,
    /// Number of results to return per page.
    pub limit: Option<i32>,
    /// The initial index from which to return the results.
    pub offset: Option<i32>
}

/// struct for passing parameters to the method [`v1_safes_transfers_list`]
#[derive(Clone, Debug, Default)]
pub struct V1SafesTransfersListParams {
    pub address: String,
    /// _from
    pub _from: Option<String>,
    /// block_number
    pub block_number: Option<String>,
    /// block_number__gt
    pub block_number__gt: Option<String>,
    /// block_number__lt
    pub block_number__lt: Option<String>,
    /// execution_date__gte
    pub execution_date__gte: Option<String>,
    /// execution_date__lte
    pub execution_date__lte: Option<String>,
    /// execution_date__gt
    pub execution_date__gt: Option<String>,
    /// execution_date__lt
    pub execution_date__lt: Option<String>,
    /// to
    pub to: Option<String>,
    /// token_address
    pub token_address: Option<String>,
    /// transaction_hash
    pub transaction_hash: Option<String>,
    /// value
    pub value: Option<String>,
    /// value__gt
    pub value__gt: Option<String>,
    /// value__lt
    pub value__lt: Option<String>,
    /// erc20
    pub erc20: Option<String>,
    /// erc721
    pub erc721: Option<String>,
    /// ether
    pub ether: Option<String>,
    /// Number of results to return per page.
    pub limit: Option<i32>,
    /// The initial index from which to return the results.
    pub offset: Option<i32>
}

/// struct for passing parameters to the method [`v1_tokens_list`]
#[derive(Clone, Debug, Default)]
pub struct V1TokensListParams {
    /// name
    pub name: Option<String>,
    /// address
    pub address: Option<String>,
    /// symbol
    pub symbol: Option<String>,
    /// decimals__lt
    pub decimals__lt: Option<String>,
    /// decimals__gt
    pub decimals__gt: Option<String>,
    /// decimals
    pub decimals: Option<String>,
    /// A search term.
    pub search: Option<String>,
    /// Which field to use when ordering the results.
    pub ordering: Option<String>,
    /// Number of results to return per page.
    pub limit: Option<i32>,
    /// The initial index from which to return the results.
    pub offset: Option<i32>
}

/// struct for passing parameters to the method [`v1_tokens_prices_usd_read`]
#[derive(Clone, Debug, Default)]
pub struct V1TokensPricesUsdReadParams {
    /// A unique value identifying this token.
    pub address: String
}

/// struct for passing parameters to the method [`v1_tokens_read`]
#[derive(Clone, Debug, Default)]
pub struct V1TokensReadParams {
    /// A unique value identifying this token.
    pub address: String
}

/// struct for passing parameters to the method [`v1_transactions_read`]
#[derive(Clone, Debug, Default)]
pub struct V1TransactionsReadParams {
    pub safe_tx_hash: String
}

/// struct for passing parameters to the method [`v1_transfer_read`]
#[derive(Clone, Debug, Default)]
pub struct V1TransferReadParams {
    pub transfer_id: String
}


/// struct for typed errors of method [`v1_about_ethereum_rpc_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1AboutEthereumRpcListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_about_ethereum_tracing_rpc_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1AboutEthereumTracingRpcListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_about_indexing_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1AboutIndexingListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_about_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1AboutListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_about_master_copies_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1AboutMasterCopiesListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_contracts_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1ContractsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_contracts_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1ContractsReadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_data_decoder_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1DataDecoderCreateError {
    Status404(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_delegates_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1DelegatesCreateError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_delegates_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1DelegatesDeleteError {
    Status400(),
    Status404(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_delegates_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1DelegatesListError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_messages_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1MessagesReadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_messages_signatures_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1MessagesSignaturesCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_module_transaction_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1ModuleTransactionReadError {
    Status404(),
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_modules_safes_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1ModulesSafesListError {
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_multisig_transactions_confirmations_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1MultisigTransactionsConfirmationsCreateError {
    Status400(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_multisig_transactions_confirmations_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1MultisigTransactionsConfirmationsListError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_multisig_transactions_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1MultisigTransactionsReadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_notifications_devices_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1NotificationsDevicesCreateError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_notifications_devices_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1NotificationsDevicesDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_notifications_devices_safes_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1NotificationsDevicesSafesDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_owners_safes_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1OwnersSafesListError {
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_all_transactions_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesAllTransactionsListError {
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_balances_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesBalancesListError {
    Status404(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_balances_usd_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesBalancesUsdListError {
    Status404(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_creation_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesCreationListError {
    Status404(),
    Status422(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_delegates_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesDelegatesDeleteError {
    Status400(),
    Status404(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_incoming_transfers_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesIncomingTransfersListError {
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_messages_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesMessagesCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_messages_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesMessagesListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_module_transactions_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesModuleTransactionsListError {
    Status400(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_multisig_transactions_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesMultisigTransactionsCreateError {
    Status400(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_multisig_transactions_estimations_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesMultisigTransactionsEstimationsCreateError {
    Status400(),
    Status404(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_multisig_transactions_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesMultisigTransactionsListError {
    Status400(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesReadError {
    Status404(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_transactions_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesTransactionsCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_transactions_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesTransactionsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_safes_transfers_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1SafesTransfersListError {
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_tokens_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1TokensListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_tokens_prices_usd_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1TokensPricesUsdReadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_tokens_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1TokensReadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_transactions_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1TransactionsReadError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_transfer_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1TransferReadError {
    Status404(),
    Status400(),
    UnknownValue(serde_json::Value),
}


/// Get information about the Ethereum RPC node used by the service
pub async fn v1_about_ethereum_rpc_list(configuration: &configuration::Configuration) -> Result<(), Error<V1AboutEthereumRpcListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/about/ethereum-rpc/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1AboutEthereumRpcListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get information about the Ethereum Tracing RPC node used by the service (if any configured)
pub async fn v1_about_ethereum_tracing_rpc_list(configuration: &configuration::Configuration) -> Result<(), Error<V1AboutEthereumTracingRpcListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/about/ethereum-tracing-rpc/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1AboutEthereumTracingRpcListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get current indexing status for ERC20/721 events
pub async fn v1_about_indexing_list(configuration: &configuration::Configuration) -> Result<Vec<crate::models::IndexingStatus>, Error<V1AboutIndexingListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/about/indexing/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1AboutIndexingListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns information and configuration of the service
pub async fn v1_about_list(configuration: &configuration::Configuration) -> Result<(), Error<V1AboutListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/about/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1AboutListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v1_about_master_copies_list(configuration: &configuration::Configuration) -> Result<Vec<crate::models::MasterCopyResponse>, Error<V1AboutMasterCopiesListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/about/master-copies/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1AboutMasterCopiesListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v1_contracts_list(configuration: &configuration::Configuration, params: V1ContractsListParams) -> Result<crate::models::V1ContractsList200Response, Error<V1ContractsListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ordering = params.ordering;
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/contracts/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ordering {
        local_var_req_builder = local_var_req_builder.query(&[("ordering", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1ContractsListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v1_contracts_read(configuration: &configuration::Configuration, params: V1ContractsReadParams) -> Result<crate::models::Contract, Error<V1ContractsReadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/contracts/{address}/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1ContractsReadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns decoded information using tx service internal ABI information given the tx data as a `0x` prefixed hexadecimal string. If address of the receiving contract is provided decoded data will be more accurate, as in case of ABI collision service will know which ABI to use.
pub async fn v1_data_decoder_create(configuration: &configuration::Configuration, params: V1DataDecoderCreateParams) -> Result<(), Error<V1DataDecoderCreateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/data-decoder/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1DataDecoderCreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a delegate for a Safe address with a custom label. Calls with same delegate but different label or signer will update the label or delegator if different. For the signature we are using TOTP with `T0=0` and `Tx=3600`. TOTP is calculated by taking the Unix UTC epoch time (no milliseconds) and dividing by 3600 (natural division, no decimals) For signature this hash need to be signed: keccak(checksummed address + str(int(current_epoch // 3600))) For example:      - We want to add the delegate `0x132512f995866CcE1b0092384A6118EDaF4508Ff` and `epoch=1586779140`.      - `TOTP = epoch // 3600 = 1586779140 // 3600 = 440771`      - The hash to sign by a Safe owner would be `keccak(\"0x132512f995866CcE1b0092384A6118EDaF4508Ff440771\")`
pub async fn v1_delegates_create(configuration: &configuration::Configuration, params: V1DelegatesCreateParams) -> Result<(), Error<V1DelegatesCreateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/delegates/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1DelegatesCreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete every pair delegate/delegator found. Signature is built the same way as for adding a delegate, but in this case the signer can be either the `delegator` (owner) or the `delegate` itself. Check `POST /delegates/`
pub async fn v1_delegates_delete(configuration: &configuration::Configuration, params: V1DelegatesDeleteParams) -> Result<(), Error<V1DelegatesDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let delegate_address = params.delegate_address;
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/delegates/{delegate_address}/", local_var_configuration.base_path, delegate_address=crate::apis::urlencode(delegate_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1DelegatesDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get list of delegates
pub async fn v1_delegates_list(configuration: &configuration::Configuration, params: V1DelegatesListParams) -> Result<crate::models::V1DelegatesList200Response, Error<V1DelegatesListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let safe = params.safe;
    let delegate = params.delegate;
    let delegator = params.delegator;
    let label = params.label;
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/delegates/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = safe {
        local_var_req_builder = local_var_req_builder.query(&[("safe", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = delegate {
        local_var_req_builder = local_var_req_builder.query(&[("delegate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = delegator {
        local_var_req_builder = local_var_req_builder.query(&[("delegator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = label {
        local_var_req_builder = local_var_req_builder.query(&[("label", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1DelegatesListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v1_messages_read(configuration: &configuration::Configuration, params: V1MessagesReadParams) -> Result<crate::models::SafeMessageResponse, Error<V1MessagesReadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let message_hash = params.message_hash;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/messages/{message_hash}/", local_var_configuration.base_path, message_hash=message_hash);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1MessagesReadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v1_messages_signatures_create(configuration: &configuration::Configuration, params: V1MessagesSignaturesCreateParams) -> Result<(), Error<V1MessagesSignaturesCreateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let message_hash = params.message_hash;
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/messages/{message_hash}/signatures/", local_var_configuration.base_path, message_hash=crate::apis::urlencode(message_hash));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1MessagesSignaturesCreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// :return: module transaction filtered by module_transaction_id
pub async fn v1_module_transaction_read(configuration: &configuration::Configuration, params: V1ModuleTransactionReadParams) -> Result<crate::models::SafeModuleTransactionResponse, Error<V1ModuleTransactionReadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let module_transaction_id = params.module_transaction_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/module-transaction/{module_transaction_id}", local_var_configuration.base_path, module_transaction_id=crate::apis::urlencode(module_transaction_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1ModuleTransactionReadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return Safes where the module address provided is enabled
pub async fn v1_modules_safes_list(configuration: &configuration::Configuration, params: V1ModulesSafesListParams) -> Result<crate::models::ModulesResponse, Error<V1ModulesSafesListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/modules/{address}/safes/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1ModulesSafesListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a confirmation for a transaction. More than one signature can be used. This endpoint does not support the use of delegates to make a transaction trusted.
pub async fn v1_multisig_transactions_confirmations_create(configuration: &configuration::Configuration, params: V1MultisigTransactionsConfirmationsCreateParams) -> Result<(), Error<V1MultisigTransactionsConfirmationsCreateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let safe_tx_hash = params.safe_tx_hash;
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/multisig-transactions/{safe_tx_hash}/confirmations/", local_var_configuration.base_path, safe_tx_hash=crate::apis::urlencode(safe_tx_hash));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1MultisigTransactionsConfirmationsCreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the list of confirmations for a multisig transaction
pub async fn v1_multisig_transactions_confirmations_list(configuration: &configuration::Configuration, params: V1MultisigTransactionsConfirmationsListParams) -> Result<crate::models::V1MultisigTransactionsConfirmationsList200Response, Error<V1MultisigTransactionsConfirmationsListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let safe_tx_hash = params.safe_tx_hash;
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/multisig-transactions/{safe_tx_hash}/confirmations/", local_var_configuration.base_path, safe_tx_hash=crate::apis::urlencode(safe_tx_hash));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1MultisigTransactionsConfirmationsListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v1_multisig_transactions_read(configuration: &configuration::Configuration, params: V1MultisigTransactionsReadParams) -> Result<crate::models::SafeMultisigTransactionResponse, Error<V1MultisigTransactionsReadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let safe_tx_hash = params.safe_tx_hash;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/multisig-transactions/{safe_tx_hash}/", local_var_configuration.base_path, safe_tx_hash=crate::apis::urlencode(safe_tx_hash));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1MultisigTransactionsReadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a new FirebaseDevice. If uuid is not provided a new device will be created. If a uuid for an existing Safe is provided the FirebaseDevice will be updated with all the new data provided. Safes provided on the request are always added and never removed/replaced Signature must sign `keccack256('gnosis-safe{timestamp-epoch}{uuid}{cloud_messaging_token}{safes_sorted}':     - `{timestamp-epoch}` must be an integer (no milliseconds)     - `{safes_sorted}` must be checksummed safe addresses sorted and joined with no spaces
pub async fn v1_notifications_devices_create(configuration: &configuration::Configuration, params: V1NotificationsDevicesCreateParams) -> Result<crate::models::FirebaseDeviceSerializerWithOwnersResponse, Error<V1NotificationsDevicesCreateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/notifications/devices/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1NotificationsDevicesCreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a FirebaseDevice
pub async fn v1_notifications_devices_delete(configuration: &configuration::Configuration, params: V1NotificationsDevicesDeleteParams) -> Result<(), Error<V1NotificationsDevicesDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let uuid = params.uuid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/notifications/devices/{uuid}/", local_var_configuration.base_path, uuid=crate::apis::urlencode(uuid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1NotificationsDevicesDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a Safe for a FirebaseDevice
pub async fn v1_notifications_devices_safes_delete(configuration: &configuration::Configuration, params: V1NotificationsDevicesSafesDeleteParams) -> Result<(), Error<V1NotificationsDevicesSafesDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let uuid = params.uuid;
    let address = params.address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/notifications/devices/{uuid}/safes/{address}/", local_var_configuration.base_path, uuid=crate::apis::urlencode(uuid), address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1NotificationsDevicesSafesDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return Safes where the address provided is an owner
pub async fn v1_owners_safes_list(configuration: &configuration::Configuration, params: V1OwnersSafesListParams) -> Result<crate::models::OwnerResponse, Error<V1OwnersSafesListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/owners/{address}/safes/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1OwnersSafesListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a paginated list of transactions for a Safe. The list has different structures depending on the transaction type: - Multisig Transactions for a Safe. `tx_type=MULTISIG_TRANSACTION`. If the query parameter `queued=False` is set only the transactions with `safe nonce < current Safe nonce` will be displayed. By default, only the `trusted` transactions will be displayed (transactions indexed, with at least one confirmation or proposed by a delegate). If you need that behaviour to be disabled set the query parameter `trusted=False` - Module Transactions for a Safe. `tx_type=MODULE_TRANSACTION` - Incoming Transfers of Ether/ERC20 Tokens/ERC721 Tokens. `tx_type=ETHEREUM_TRANSACTION`
pub async fn v1_safes_all_transactions_list(configuration: &configuration::Configuration, params: V1SafesAllTransactionsListParams) -> Result<crate::models::AllTransactionsSchema, Error<V1SafesAllTransactionsListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let ordering = params.ordering;
    let limit = params.limit;
    let offset = params.offset;
    let executed = params.executed;
    let queued = params.queued;
    let trusted = params.trusted;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/all-transactions/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ordering {
        local_var_req_builder = local_var_req_builder.query(&[("ordering", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = executed {
        local_var_req_builder = local_var_req_builder.query(&[("executed", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = queued {
        local_var_req_builder = local_var_req_builder.query(&[("queued", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trusted {
        local_var_req_builder = local_var_req_builder.query(&[("trusted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1SafesAllTransactionsListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get balance for Ether and ERC20 tokens
pub async fn v1_safes_balances_list(configuration: &configuration::Configuration, params: V1SafesBalancesListParams) -> Result<Vec<crate::models::SafeBalanceResponse>, Error<V1SafesBalancesListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let trusted = params.trusted;
    let exclude_spam = params.exclude_spam;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/balances/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = trusted {
        local_var_req_builder = local_var_req_builder.query(&[("trusted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_spam {
        local_var_req_builder = local_var_req_builder.query(&[("exclude_spam", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1SafesBalancesListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get balance for Ether and ERC20 tokens with USD fiat conversion
pub async fn v1_safes_balances_usd_list(configuration: &configuration::Configuration, params: V1SafesBalancesUsdListParams) -> Result<Vec<crate::models::SafeBalanceUsdResponse>, Error<V1SafesBalancesUsdListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let trusted = params.trusted;
    let exclude_spam = params.exclude_spam;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/balances/usd/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = trusted {
        local_var_req_builder = local_var_req_builder.query(&[("trusted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_spam {
        local_var_req_builder = local_var_req_builder.query(&[("exclude_spam", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1SafesBalancesUsdListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get status of the safe
pub async fn v1_safes_creation_list(configuration: &configuration::Configuration, params: V1SafesCreationListParams) -> Result<crate::models::SafeCreationInfoResponse, Error<V1SafesCreationListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/creation/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1SafesCreationListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a delegate for a Safe. Signature is built the same way that for adding a delegate. Check `POST /delegates/`
pub async fn v1_safes_delegates_delete(configuration: &configuration::Configuration, params: V1SafesDelegatesDeleteParams) -> Result<(), Error<V1SafesDelegatesDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let delegate_address = params.delegate_address;
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/delegates/{delegate_address}/", local_var_configuration.base_path, address=crate::apis::urlencode(address), delegate_address=crate::apis::urlencode(delegate_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1SafesDelegatesDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns incoming ether/tokens transfers for a Safe
pub async fn v1_safes_incoming_transfers_list(configuration: &configuration::Configuration, params: V1SafesIncomingTransfersListParams) -> Result<Vec<crate::models::TransferWithTokenInfoResponse>, Error<V1SafesIncomingTransfersListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let _from = params._from;
    let block_number = params.block_number;
    let block_number__gt = params.block_number__gt;
    let block_number__lt = params.block_number__lt;
    let execution_date__gte = params.execution_date__gte;
    let execution_date__lte = params.execution_date__lte;
    let execution_date__gt = params.execution_date__gt;
    let execution_date__lt = params.execution_date__lt;
    let to = params.to;
    let token_address = params.token_address;
    let transaction_hash = params.transaction_hash;
    let value = params.value;
    let value__gt = params.value__gt;
    let value__lt = params.value__lt;
    let erc20 = params.erc20;
    let erc721 = params.erc721;
    let ether = params.ether;
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/incoming-transfers/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = _from {
        local_var_req_builder = local_var_req_builder.query(&[("_from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_number {
        local_var_req_builder = local_var_req_builder.query(&[("block_number", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_number__gt {
        local_var_req_builder = local_var_req_builder.query(&[("block_number__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_number__lt {
        local_var_req_builder = local_var_req_builder.query(&[("block_number__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = execution_date__gte {
        local_var_req_builder = local_var_req_builder.query(&[("execution_date__gte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = execution_date__lte {
        local_var_req_builder = local_var_req_builder.query(&[("execution_date__lte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = execution_date__gt {
        local_var_req_builder = local_var_req_builder.query(&[("execution_date__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = execution_date__lt {
        local_var_req_builder = local_var_req_builder.query(&[("execution_date__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = to {
        local_var_req_builder = local_var_req_builder.query(&[("to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = token_address {
        local_var_req_builder = local_var_req_builder.query(&[("token_address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = transaction_hash {
        local_var_req_builder = local_var_req_builder.query(&[("transaction_hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = value {
        local_var_req_builder = local_var_req_builder.query(&[("value", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = value__gt {
        local_var_req_builder = local_var_req_builder.query(&[("value__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = value__lt {
        local_var_req_builder = local_var_req_builder.query(&[("value__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = erc20 {
        local_var_req_builder = local_var_req_builder.query(&[("erc20", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = erc721 {
        local_var_req_builder = local_var_req_builder.query(&[("erc721", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ether {
        local_var_req_builder = local_var_req_builder.query(&[("ether", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1SafesIncomingTransfersListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new signed message for a Safe. Message can be: - A ``string``, so ``EIP191`` will be used to get the hash. - An ``EIP712`` ``object``.  Hash will be calculated from the provided ``message``. Sending a raw ``hash`` will not be accepted, service needs to derive it itself.
pub async fn v1_safes_messages_create(configuration: &configuration::Configuration, params: V1SafesMessagesCreateParams) -> Result<(), Error<V1SafesMessagesCreateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/messages/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1SafesMessagesCreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v1_safes_messages_list(configuration: &configuration::Configuration, params: V1SafesMessagesListParams) -> Result<crate::models::V1SafesMessagesList200Response, Error<V1SafesMessagesListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let ordering = params.ordering;
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/messages/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ordering {
        local_var_req_builder = local_var_req_builder.query(&[("ordering", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1SafesMessagesListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the module transaction of a Safe
pub async fn v1_safes_module_transactions_list(configuration: &configuration::Configuration, params: V1SafesModuleTransactionsListParams) -> Result<crate::models::V1SafesModuleTransactionsList200Response, Error<V1SafesModuleTransactionsListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let safe = params.safe;
    let module = params.module;
    let to = params.to;
    let operation = params.operation;
    let failed = params.failed;
    let block_number = params.block_number;
    let block_number__gt = params.block_number__gt;
    let block_number__lt = params.block_number__lt;
    let transaction_hash = params.transaction_hash;
    let ordering = params.ordering;
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/module-transactions/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = safe {
        local_var_req_builder = local_var_req_builder.query(&[("safe", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = module {
        local_var_req_builder = local_var_req_builder.query(&[("module", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = to {
        local_var_req_builder = local_var_req_builder.query(&[("to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = operation {
        local_var_req_builder = local_var_req_builder.query(&[("operation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = failed {
        local_var_req_builder = local_var_req_builder.query(&[("failed", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_number {
        local_var_req_builder = local_var_req_builder.query(&[("block_number", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_number__gt {
        local_var_req_builder = local_var_req_builder.query(&[("block_number__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_number__lt {
        local_var_req_builder = local_var_req_builder.query(&[("block_number__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = transaction_hash {
        local_var_req_builder = local_var_req_builder.query(&[("transaction_hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ordering {
        local_var_req_builder = local_var_req_builder.query(&[("ordering", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1SafesModuleTransactionsListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a Multisig Transaction with its confirmations and retrieves all the information related.
pub async fn v1_safes_multisig_transactions_create(configuration: &configuration::Configuration, params: V1SafesMultisigTransactionsCreateParams) -> Result<(), Error<V1SafesMultisigTransactionsCreateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/multisig-transactions/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1SafesMultisigTransactionsCreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Estimates `safeTxGas` for a Safe Multisig Transaction.
pub async fn v1_safes_multisig_transactions_estimations_create(configuration: &configuration::Configuration, params: V1SafesMultisigTransactionsEstimationsCreateParams) -> Result<crate::models::SafeMultisigTransactionEstimateResponse, Error<V1SafesMultisigTransactionsEstimationsCreateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/multisig-transactions/estimations/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1SafesMultisigTransactionsEstimationsCreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the history of a multisig tx (safe)
pub async fn v1_safes_multisig_transactions_list(configuration: &configuration::Configuration, params: V1SafesMultisigTransactionsListParams) -> Result<crate::models::V1SafesMultisigTransactionsList200Response, Error<V1SafesMultisigTransactionsListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let failed = params.failed;
    let modified__lt = params.modified__lt;
    let modified__gt = params.modified__gt;
    let modified__lte = params.modified__lte;
    let modified__gte = params.modified__gte;
    let nonce__lt = params.nonce__lt;
    let nonce__gt = params.nonce__gt;
    let nonce__lte = params.nonce__lte;
    let nonce__gte = params.nonce__gte;
    let nonce = params.nonce;
    let safe_tx_hash = params.safe_tx_hash;
    let to = params.to;
    let value__lt = params.value__lt;
    let value__gt = params.value__gt;
    let value = params.value;
    let executed = params.executed;
    let has_confirmations = params.has_confirmations;
    let trusted = params.trusted;
    let execution_date__gte = params.execution_date__gte;
    let execution_date__lte = params.execution_date__lte;
    let submission_date__gte = params.submission_date__gte;
    let submission_date__lte = params.submission_date__lte;
    let transaction_hash = params.transaction_hash;
    let ordering = params.ordering;
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/multisig-transactions/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = failed {
        local_var_req_builder = local_var_req_builder.query(&[("failed", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = modified__lt {
        local_var_req_builder = local_var_req_builder.query(&[("modified__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = modified__gt {
        local_var_req_builder = local_var_req_builder.query(&[("modified__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = modified__lte {
        local_var_req_builder = local_var_req_builder.query(&[("modified__lte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = modified__gte {
        local_var_req_builder = local_var_req_builder.query(&[("modified__gte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = nonce__lt {
        local_var_req_builder = local_var_req_builder.query(&[("nonce__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = nonce__gt {
        local_var_req_builder = local_var_req_builder.query(&[("nonce__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = nonce__lte {
        local_var_req_builder = local_var_req_builder.query(&[("nonce__lte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = nonce__gte {
        local_var_req_builder = local_var_req_builder.query(&[("nonce__gte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = nonce {
        local_var_req_builder = local_var_req_builder.query(&[("nonce", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = safe_tx_hash {
        local_var_req_builder = local_var_req_builder.query(&[("safe_tx_hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = to {
        local_var_req_builder = local_var_req_builder.query(&[("to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = value__lt {
        local_var_req_builder = local_var_req_builder.query(&[("value__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = value__gt {
        local_var_req_builder = local_var_req_builder.query(&[("value__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = value {
        local_var_req_builder = local_var_req_builder.query(&[("value", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = executed {
        local_var_req_builder = local_var_req_builder.query(&[("executed", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_confirmations {
        local_var_req_builder = local_var_req_builder.query(&[("has_confirmations", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trusted {
        local_var_req_builder = local_var_req_builder.query(&[("trusted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = execution_date__gte {
        local_var_req_builder = local_var_req_builder.query(&[("execution_date__gte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = execution_date__lte {
        local_var_req_builder = local_var_req_builder.query(&[("execution_date__lte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = submission_date__gte {
        local_var_req_builder = local_var_req_builder.query(&[("submission_date__gte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = submission_date__lte {
        local_var_req_builder = local_var_req_builder.query(&[("submission_date__lte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = transaction_hash {
        local_var_req_builder = local_var_req_builder.query(&[("transaction_hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ordering {
        local_var_req_builder = local_var_req_builder.query(&[("ordering", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1SafesMultisigTransactionsListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get status of the safe
pub async fn v1_safes_read(configuration: &configuration::Configuration, params: V1SafesReadParams) -> Result<crate::models::SafeInfoResponse, Error<V1SafesReadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1SafesReadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Use `multisig-transactions` instead of `transactions`
pub async fn v1_safes_transactions_create(configuration: &configuration::Configuration, params: V1SafesTransactionsCreateParams) -> Result<crate::models::SafeMultisigTransaction, Error<V1SafesTransactionsCreateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/transactions/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1SafesTransactionsCreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Use `multisig-transactions` instead of `transactions`
pub async fn v1_safes_transactions_list(configuration: &configuration::Configuration, params: V1SafesTransactionsListParams) -> Result<crate::models::V1SafesMultisigTransactionsList200Response, Error<V1SafesTransactionsListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let failed = params.failed;
    let modified__lt = params.modified__lt;
    let modified__gt = params.modified__gt;
    let modified__lte = params.modified__lte;
    let modified__gte = params.modified__gte;
    let nonce__lt = params.nonce__lt;
    let nonce__gt = params.nonce__gt;
    let nonce__lte = params.nonce__lte;
    let nonce__gte = params.nonce__gte;
    let nonce = params.nonce;
    let safe_tx_hash = params.safe_tx_hash;
    let to = params.to;
    let value__lt = params.value__lt;
    let value__gt = params.value__gt;
    let value = params.value;
    let executed = params.executed;
    let has_confirmations = params.has_confirmations;
    let trusted = params.trusted;
    let execution_date__gte = params.execution_date__gte;
    let execution_date__lte = params.execution_date__lte;
    let submission_date__gte = params.submission_date__gte;
    let submission_date__lte = params.submission_date__lte;
    let transaction_hash = params.transaction_hash;
    let ordering = params.ordering;
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/transactions/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = failed {
        local_var_req_builder = local_var_req_builder.query(&[("failed", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = modified__lt {
        local_var_req_builder = local_var_req_builder.query(&[("modified__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = modified__gt {
        local_var_req_builder = local_var_req_builder.query(&[("modified__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = modified__lte {
        local_var_req_builder = local_var_req_builder.query(&[("modified__lte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = modified__gte {
        local_var_req_builder = local_var_req_builder.query(&[("modified__gte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = nonce__lt {
        local_var_req_builder = local_var_req_builder.query(&[("nonce__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = nonce__gt {
        local_var_req_builder = local_var_req_builder.query(&[("nonce__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = nonce__lte {
        local_var_req_builder = local_var_req_builder.query(&[("nonce__lte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = nonce__gte {
        local_var_req_builder = local_var_req_builder.query(&[("nonce__gte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = nonce {
        local_var_req_builder = local_var_req_builder.query(&[("nonce", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = safe_tx_hash {
        local_var_req_builder = local_var_req_builder.query(&[("safe_tx_hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = to {
        local_var_req_builder = local_var_req_builder.query(&[("to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = value__lt {
        local_var_req_builder = local_var_req_builder.query(&[("value__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = value__gt {
        local_var_req_builder = local_var_req_builder.query(&[("value__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = value {
        local_var_req_builder = local_var_req_builder.query(&[("value", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = executed {
        local_var_req_builder = local_var_req_builder.query(&[("executed", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_confirmations {
        local_var_req_builder = local_var_req_builder.query(&[("has_confirmations", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trusted {
        local_var_req_builder = local_var_req_builder.query(&[("trusted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = execution_date__gte {
        local_var_req_builder = local_var_req_builder.query(&[("execution_date__gte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = execution_date__lte {
        local_var_req_builder = local_var_req_builder.query(&[("execution_date__lte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = submission_date__gte {
        local_var_req_builder = local_var_req_builder.query(&[("submission_date__gte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = submission_date__lte {
        local_var_req_builder = local_var_req_builder.query(&[("submission_date__lte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = transaction_hash {
        local_var_req_builder = local_var_req_builder.query(&[("transaction_hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ordering {
        local_var_req_builder = local_var_req_builder.query(&[("ordering", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1SafesTransactionsListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns ether/tokens transfers for a Safe
pub async fn v1_safes_transfers_list(configuration: &configuration::Configuration, params: V1SafesTransfersListParams) -> Result<Vec<crate::models::TransferWithTokenInfoResponse>, Error<V1SafesTransfersListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;
    let _from = params._from;
    let block_number = params.block_number;
    let block_number__gt = params.block_number__gt;
    let block_number__lt = params.block_number__lt;
    let execution_date__gte = params.execution_date__gte;
    let execution_date__lte = params.execution_date__lte;
    let execution_date__gt = params.execution_date__gt;
    let execution_date__lt = params.execution_date__lt;
    let to = params.to;
    let token_address = params.token_address;
    let transaction_hash = params.transaction_hash;
    let value = params.value;
    let value__gt = params.value__gt;
    let value__lt = params.value__lt;
    let erc20 = params.erc20;
    let erc721 = params.erc721;
    let ether = params.ether;
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/safes/{address}/transfers/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = _from {
        local_var_req_builder = local_var_req_builder.query(&[("_from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_number {
        local_var_req_builder = local_var_req_builder.query(&[("block_number", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_number__gt {
        local_var_req_builder = local_var_req_builder.query(&[("block_number__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_number__lt {
        local_var_req_builder = local_var_req_builder.query(&[("block_number__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = execution_date__gte {
        local_var_req_builder = local_var_req_builder.query(&[("execution_date__gte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = execution_date__lte {
        local_var_req_builder = local_var_req_builder.query(&[("execution_date__lte", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = execution_date__gt {
        local_var_req_builder = local_var_req_builder.query(&[("execution_date__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = execution_date__lt {
        local_var_req_builder = local_var_req_builder.query(&[("execution_date__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = to {
        local_var_req_builder = local_var_req_builder.query(&[("to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = token_address {
        local_var_req_builder = local_var_req_builder.query(&[("token_address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = transaction_hash {
        local_var_req_builder = local_var_req_builder.query(&[("transaction_hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = value {
        local_var_req_builder = local_var_req_builder.query(&[("value", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = value__gt {
        local_var_req_builder = local_var_req_builder.query(&[("value__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = value__lt {
        local_var_req_builder = local_var_req_builder.query(&[("value__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = erc20 {
        local_var_req_builder = local_var_req_builder.query(&[("erc20", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = erc721 {
        local_var_req_builder = local_var_req_builder.query(&[("erc721", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ether {
        local_var_req_builder = local_var_req_builder.query(&[("ether", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1SafesTransfersListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v1_tokens_list(configuration: &configuration::Configuration, params: V1TokensListParams) -> Result<crate::models::V1TokensList200Response, Error<V1TokensListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let address = params.address;
    let symbol = params.symbol;
    let decimals__lt = params.decimals__lt;
    let decimals__gt = params.decimals__gt;
    let decimals = params.decimals;
    let search = params.search;
    let ordering = params.ordering;
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/tokens/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = name {
        local_var_req_builder = local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = address {
        local_var_req_builder = local_var_req_builder.query(&[("address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = symbol {
        local_var_req_builder = local_var_req_builder.query(&[("symbol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = decimals__lt {
        local_var_req_builder = local_var_req_builder.query(&[("decimals__lt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = decimals__gt {
        local_var_req_builder = local_var_req_builder.query(&[("decimals__gt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = decimals {
        local_var_req_builder = local_var_req_builder.query(&[("decimals", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = search {
        local_var_req_builder = local_var_req_builder.query(&[("search", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ordering {
        local_var_req_builder = local_var_req_builder.query(&[("ordering", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1TokensListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v1_tokens_prices_usd_read(configuration: &configuration::Configuration, params: V1TokensPricesUsdReadParams) -> Result<crate::models::TokenPriceResponse, Error<V1TokensPricesUsdReadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/tokens/{address}/prices/usd/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1TokensPricesUsdReadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v1_tokens_read(configuration: &configuration::Configuration, params: V1TokensReadParams) -> Result<crate::models::TokenInfoResponse, Error<V1TokensReadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let address = params.address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/tokens/{address}/", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1TokensReadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Use `multisig-transactions` instead of `transactions`
pub async fn v1_transactions_read(configuration: &configuration::Configuration, params: V1TransactionsReadParams) -> Result<(), Error<V1TransactionsReadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let safe_tx_hash = params.safe_tx_hash;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/transactions/{safe_tx_hash}/", local_var_configuration.base_path, safe_tx_hash=crate::apis::urlencode(safe_tx_hash));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<V1TransactionsReadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// :return: transfer filtered by transfer_id
pub async fn v1_transfer_read(configuration: &configuration::Configuration, params: V1TransferReadParams) -> Result<crate::models::TransferWithTokenInfoResponse, Error<V1TransferReadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let transfer_id = params.transfer_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/transfer/{transfer_id}", local_var_configuration.base_path, transfer_id=crate::apis::urlencode(transfer_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V1TransferReadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

